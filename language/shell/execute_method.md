# Shell 脚本的执行方式

在本文中，我们将会讲解几种不同的 shell 命令的执行方式，并对它们的不同之处进行对比。

## bash filename.sh

首先，我们来介绍最常用的一种执行方式。

以一个 `test1.sh` 脚本为例：

```shell
a="hello world!"
echo a
```

当我们执行 `bash test1.sh` 命令时，实际是我 fork 一个子进程，并通过 bash 解释器来执行来脚本。

## ./filename.sh

当一个 shell 脚本本身有执行权限时，我们可以执行执行该文件，而无须添加 `bash` 命令即可。

但是，此时具体该文件使用哪种解释器来执行呢？其实是取决与该文件头的 Sha-Bang。

例如，`test2.sh` 脚本如下：

```shell
#!/usr/bin/env bash
a="hello world!"
echo a
```

注意上述文件的第一行，表名了直接执行该文件时，是通过 bash 的方式进行执行。


## source filename.sh

`source` 的方式执行一个文件与上述方式最大的区别是：source 方式是在当前进程下执行该命令，而不是 fork 了一个新的进程。

是否是 fork 新的进程实际上会有什么影响呢？

从之前的文章中，我们都知道在 shell 中变量是有作用域的，例如函数内部的局部变量，默认的全局变量以及环境变量的。

还记得环境变量和全局变量的区别嘛？

环境变量可以在当前的进程及其子进程中都生效，而全局变量仅仅能在当前进程下生效。

因此，可以看出，是否 fork 子进程执行命令其实更多的是影响了全局变量/环境变量的生效。

例如，如果我们在一个脚本 `test3.sh` 中，定义了各种全局变量和环境变量：

```shell
export NAME=wangzhe12
export AGE=29
message="hello world!"
```

如果我们使用 `sh test3.sh` 的方式执行完成后，再次查询NAME和message等变量其实并没有实际生效。
其原因就是在子进程中，设置的全局变量和环境变量都不会影响到父进程或其他进程。

而如果我们使用 `source test3.sh` 的方式执行后，再次查询NAME和message等变量可以看到全部都生效了，因为它们始终在同一进程中。

除了变量的设置外，例如，我们在 shell 脚本中包含了 cd 等之类的命令，
如果通过 bash 的方式执行，执行完成后，当前终端所在的目录也是不会发现变化的，真正切换目录的只是 fork 出的子进程而已。
而通过 source 的方式执行，实际上相当于在当前进程中依次执行了 shell 中的命令，当前终端所在目录也会实际变化。

## . filename.sh

最后，我们来看一下 `. filename.sh` 这种执行方式：

**`. filename.sh` 的执行方式等价于 `source filename.sh`。**
