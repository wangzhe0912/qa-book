# 库源码文件

在上一节中，我们已经用Go语言编写了一个小命令了。

但是这些"小命令"其实并没有什么实际的作用，但是别着急，下面我们会一点点的学习，逐步写出完整功能的程序。

## 什么是库源码文件

**库源码文件是不能被直接运行的源码文件**，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。

这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。

那么，什么是程序实体呢？

在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。

我们总是会先声明（或者说定义）程序实体，然后再去使用。比如在上一篇的例子中，我们先定义了变量name，然后在main函数中调用fmt.Printf函数的时候用到了它。

Ps：程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。

从规则上说，我们可以用中文作为变量的名字。但是，这种命名方式非常不好，大部分开发团队中明令禁止这种做法。作为一名合格的程序员，我们应该向着编写国际水准的程序无限逼近。

## 知识精讲

下面，我们来看下怎么把命令源码文件中的代码拆分到其他库源码文件？下面，我们来用代码进行说明：

如果在某个目录下，有一个命令源码文件为`demo4.go`：

```go
package main

import (
  "flag"
)

var name string

func init() {
  flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
  flag.Parse()
  hello(name)
}
```

其中，可以看到在上述代码的`main`函数中调用了一个不在当前文件定义的`hello`函数。

因此，我们需要在`demo4.go`的相同目录下创建一个源码文件`demo4_lib.go`文件，内容如下：

```go
package main

import "fmt"

func hello(name string) {
  fmt.Printf("Hello, %s!\n", name)
}
```

Ps：需要注意的是，在`demo4_lib.go`文件的第一行中，我们定义该文件同样属于`main` package。
这就是我们之前说的，在Go语言中同一个目录下的文件都需要属于同一个package。

此时，我们就可以运行他们了。

```go
$ go run demo4.go demo4_lib.go
Hello, everyone!
```

Ps：从上述内容可以看出，在Go语言中，同一个包的不同文件中的函数在调用时无需`import`语句，就可以直接使用。

对于编写一个大型的项目而言，仅仅将代码拆分到几个源码文件是不够的，我们往往会使用模块化的方式进行编程。
从而，根据代码的功能和用途把它们放置到不同的代码包中。

那么，把代码拆分到不同的package中时，又需要注意哪些问题呢？

还是以上述内容为例，假设目录结构如下：

```
.
├── lib5
│   └── lib.go
└── main
    └── demo5.go
```

此时，`lib.go`的文件内容如下：

```go
package lib5

import "fmt"

func Hello(name string) {
  fmt.Printf("Hello, %s!\n", name)
}
```

可以看到，该文件和之前文件内容主要有如下两个区别：

1. 把`package main`修改为了`package lib5`。
2. `hello`函数的定义修改为了`Hello`。

其中：
第一点说明了对于不同的目录需要使用不同的package名称。
第二点说明了在Go语言中，大写字母开头的函数、变量是可以在当前包外被引用的，而小写字母开头的函数、变量只能在包内使用。

此外，我们还需要修改`demo4.go`的文件中增加一行：

```go
import "lib5"
```

## 总结

我们在本篇文章中详细讨论了把代码从命令源码文件中拆分出来的方法，这包括拆分到其他库源码文件，以及拆分到其他代码包。

这里涉及了几条重要的 Go 语言基本编码规则，即：代码包声明规则、代码包导入规则等。

你必须记住这些规则，否则你的代码很可能无法通过编译。

## 思考

### 问题1. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？

答：import后路径最后一级相同，不一定会冲突。

分为两种情况:

a.如果文件夹下文件声明的包名相同，则肯定冲突，会报错redeclared。

b.如果文件夹下文件声明的包名不同，也不会冲突。


### 问题2. 如果会产生冲突，那么怎样解决这种冲突，有几种方式？

答：给包设置别名,调用的时候来区分开不同的package,比如:

```go
import b "bbbb"
```

格式如下：

```go
import alias "${package}"
```
