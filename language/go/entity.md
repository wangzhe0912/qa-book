# 程序实体概述

在本节中，我们将会初步学习Go语言中的实体的通用逻辑，包括变量、常量、函数、结构体、接口等。

Go 语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。

PS：在 Go 语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些。

## 变量的声明

一种常用方式如下：

```go
var name string
name = "hello world"
```

另外一种更加简单的方式如下：

```go
name := "hello world"
```

看起来在上面的方法好像并没有明确指名name的变量类型，但实际上，这里利用了Go语言自身的类型推断，可以从赋值的信息中自动推断出新的变量一定是string类型。

Ps：需要说明的是，第二种方式仅限于在函数内部使用。

这样使用的一个好处是可以大大增加程序的灵活性：

```go
package main

import (
  "flag"
  "fmt"
)

func main() {
  name := getTheFlag()
  flag.Parse()
  fmt.Printf("Hello, %v!\n", *name)
}

func getTheFlag() *string {
  return flag.String("name", "everyone", "The greeting object.")
}
```

以上述程序为例，name其实可以是任意类型变量，我们可以对getTheFlag函数进行任意修改，甚至修改其返回类型，外部程序都能很多的做到兼容。


## 变量的重声明

重声明就是指对已经声明过的变量再次声明。变量重声明的前提条件如下:

1. 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。
2. 变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，后续我们会提及。
3. 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。
4. 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。

示例如下：

```go
var err error
n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")
```

## 程序实体的作用域

在 Go 语言中，代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。

Go 语言本身以及我们编写的代码共同形成了一个非常大的代码块，也叫全域代码块。

这主要体现在，只要是公开的全局变量，都可以被任何代码所使用。

相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大。

接下来，每个源码文件也都是一个代码块，每个函数也是一个代码块，每个if语句、for语句、switch语句和select语句都是一个代码块。

甚至，switch或select语句中的case子句也都是独立的代码块。

走个极端，我就在main函数中写一对紧挨着的花括号算不算一个代码块？当然也算，这甚至还有个名词，叫“空代码块”。

也就是说：一个代码块可以有若干个子代码块；但对于每个代码块，最多只会有一个直接包含它的代码块（后者可以简称为前者的外层代码块）。

这种代码块的划分，也间接地决定了程序实体的**作用域**。下面，我们来进行详细说明。

大家都知道，一个程序实体被创造出来，是为了让别的代码引用的。那么，哪里的代码可以引用它呢，这就涉及了它的作用域。

程序实体的访问权限有三种：**包级私有的**、**模块级私有的**和**公开的**。

包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。
然而，这个粒度是比较粗的，我们往往需要利用代码块再细化程序实体的作用域。

比如，我在一个函数中声明了一个变量，那么在通常情况下，这个变量是无法被这个函数以外的代码引用的。这里的函数就是一个代码块，而变量的作用域被限制在了该代码块中。

简单的说：一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。

思考一个问题：如果一个变量与其外层代码块中的变量重名会出现什么状况？我们通过一段代码来验证一下：

```go
package main

import "fmt"

var block = "package"

func main() {
  block := "function"
  {
    block := "inner"
    fmt.Printf("The block is %s.\n", block)
  }
  fmt.Printf("The block is %s.\n", block)
}
```

这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。

我在后三个代码块中分别声明了一个名为block的变量，并分别把字符串值"package"、"function"和"inner"赋给了它们。
此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。

那么，上述代码可以通过编译吗？如果能，会打印的结果是什么呢？

实际上，上述代码是可以通过编译的，打印的结果如下：

```go
The block is inner.
The block is function.
```
